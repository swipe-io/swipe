//+build !swipe

// Code generated by Swipe v2.0.0-rc4. DO NOT EDIT.

package app

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
	"github.com/l-vitaly/go-kit/transport/http/jsonrpc"
	"github.com/pquerna/ffjson/ffjson"
)

func MergeEndpointCodecMaps(ecms ...jsonrpc.EndpointCodecMap) jsonrpc.EndpointCodecMap {
	mergedECM := make(jsonrpc.EndpointCodecMap, 512)
	for _, ecm := range ecms {
		for key, codec := range ecm {
			mergedECM[key] = codec
		}
	}
	return mergedECM
}
func encodeResponseJSONRPC(_ context.Context, result interface{}) (json.RawMessage, error) {
	b, err := ffjson.Marshal(result)
	if err != nil {
		return nil, err
	}
	return b, nil
}

func MakeInterfaceAEndpointCodecMap(ep InterfaceAEndpointSet, ns ...string) jsonrpc.EndpointCodecMap {
	var namespace string
	if len(ns) > 0 {
		namespace = strings.Join(ns, ".") + "."
	}
	ecm := jsonrpc.EndpointCodecMap{}
	if ep.TestMethodEndpoint != nil {
		ecm[namespace+"testMethod"] = jsonrpc.EndpointCodec{
			Endpoint: ep.TestMethodEndpoint,
			Decode: func(_ context.Context, msg json.RawMessage) (interface{}, error) {
				return nil, nil
			},
			Encode: encodeResponseJSONRPC,
		}
	}
	return ecm
}

func MakeInterfaceBEndpointCodecMap(ep InterfaceBEndpointSet, ns ...string) jsonrpc.EndpointCodecMap {
	var namespace string
	if len(ns) > 0 {
		namespace = strings.Join(ns, ".") + "."
	}
	ecm := jsonrpc.EndpointCodecMap{}
	if ep.CreateEndpoint != nil {
		ecm[namespace+"create"] = jsonrpc.EndpointCodec{
			Endpoint: ep.CreateEndpoint,
			Decode: func(_ context.Context, msg json.RawMessage) (interface{}, error) {
				var req InterfaceBCreateRequest
				err := ffjson.Unmarshal(msg, &req)
				if err != nil {
					return nil, fmt.Errorf("couldn't unmarshal body to InterfaceBCreateRequest: %s", err)
				}
				return req, nil
			},
			Encode: encodeResponseJSONRPC,
		}
	}
	if ep.DeleteEndpoint != nil {
		ecm[namespace+"delete"] = jsonrpc.EndpointCodec{
			Endpoint: ep.DeleteEndpoint,
			Decode: func(_ context.Context, msg json.RawMessage) (interface{}, error) {
				var req InterfaceBDeleteRequest
				err := ffjson.Unmarshal(msg, &req)
				if err != nil {
					return nil, fmt.Errorf("couldn't unmarshal body to InterfaceBDeleteRequest: %s", err)
				}
				return req, nil
			},
			Encode: encodeResponseJSONRPC,
		}
	}
	if ep.GetEndpoint != nil {
		ecm[namespace+"get"] = jsonrpc.EndpointCodec{
			Endpoint: ep.GetEndpoint,
			Decode: func(_ context.Context, msg json.RawMessage) (interface{}, error) {
				var req InterfaceBGetRequest
				err := ffjson.Unmarshal(msg, &req)
				if err != nil {
					return nil, fmt.Errorf("couldn't unmarshal body to InterfaceBGetRequest: %s", err)
				}
				return req, nil
			},
			Encode: encodeResponseJSONRPC,
		}
	}
	if ep.GetAllEndpoint != nil {
		ecm[namespace+"getAll"] = jsonrpc.EndpointCodec{
			Endpoint: ep.GetAllEndpoint,
			Decode: func(_ context.Context, msg json.RawMessage) (interface{}, error) {
				var req InterfaceBGetAllRequest
				err := ffjson.Unmarshal(msg, &req)
				if err != nil {
					return nil, fmt.Errorf("couldn't unmarshal body to InterfaceBGetAllRequest: %s", err)
				}
				return req, nil
			},
			Encode: encodeResponseJSONRPC,
		}
	}
	if ep.TestMethodEndpoint != nil {
		ecm[namespace+"testMethod"] = jsonrpc.EndpointCodec{
			Endpoint: ep.TestMethodEndpoint,
			Decode: func(_ context.Context, msg json.RawMessage) (interface{}, error) {
				var req InterfaceBTestMethodRequest
				err := ffjson.Unmarshal(msg, &req)
				if err != nil {
					return nil, fmt.Errorf("couldn't unmarshal body to InterfaceBTestMethodRequest: %s", err)
				}
				return req, nil
			},
			Encode: encodeResponseJSONRPC,
		}
	}
	if ep.TestMethod2Endpoint != nil {
		ecm[namespace+"testMethod2"] = jsonrpc.EndpointCodec{
			Endpoint: ep.TestMethod2Endpoint,
			Decode: func(_ context.Context, msg json.RawMessage) (interface{}, error) {
				var req InterfaceBTestMethod2Request
				err := ffjson.Unmarshal(msg, &req)
				if err != nil {
					return nil, fmt.Errorf("couldn't unmarshal body to InterfaceBTestMethod2Request: %s", err)
				}
				return req, nil
			},
			Encode: encodeResponseJSONRPC,
		}
	}
	return ecm
}

// HTTP JSONRPC Transport
func MakeHandlerJSONRPC(svcInterfaceA InterfaceA, svcInterfaceB InterfaceB, options ...ServerOption) (http.Handler, error) {
	opts := &serverOpts{}
	for _, o := range options {
		o(opts)
	}
	epSetA := MakeInterfaceAEndpointSet(svcInterfaceA)
	epSetA.TestMethodEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.interfaceATestMethodEndpointMiddleware...))(epSetA.TestMethodEndpoint)
	epSetB := MakeInterfaceBEndpointSet(svcInterfaceB)
	epSetB.CreateEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.interfaceBCreateEndpointMiddleware...))(epSetB.CreateEndpoint)
	epSetB.DeleteEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.interfaceBDeleteEndpointMiddleware...))(epSetB.DeleteEndpoint)
	epSetB.GetEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.interfaceBGetEndpointMiddleware...))(epSetB.GetEndpoint)
	epSetB.GetAllEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.interfaceBGetAllEndpointMiddleware...))(epSetB.GetAllEndpoint)
	epSetB.TestMethodEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.interfaceBTestMethodEndpointMiddleware...))(epSetB.TestMethodEndpoint)
	epSetB.TestMethod2Endpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.interfaceBTestMethod2EndpointMiddleware...))(epSetB.TestMethod2Endpoint)
	r := mux.NewRouter()
	handler := jsonrpc.NewServer(MergeEndpointCodecMaps(MakeInterfaceAEndpointCodecMap(epSetA, "a"), MakeInterfaceBEndpointCodecMap(epSetB, "b")), opts.genericServerOption...)
	r.Methods("POST").Path("").Handler(handler)
	return r, nil
}
