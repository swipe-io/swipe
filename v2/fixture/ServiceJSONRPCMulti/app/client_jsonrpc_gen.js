// Code generated by Swipe v2.0.0-rc4. DO NOT EDIT.

export class JSONRPCError extends Error {
  constructor(message, name, code, data) {
    super(message);
    this.name = name;
    this.code = code;
    this.data = data;
  }
}

class JSONRPCScheduler {
  /**
   *
   * @param {*} transport
   */
  constructor(transport) {
    this._transport = transport;
    this._requestID = 0;
    this._scheduleRequests = {};
    this._commitTimerID = null;
    this._beforeRequest = null;
  }
  beforeRequest(fn) {
    this._beforeRequest = fn;
  }
  __scheduleCommit() {
    if (this._commitTimerID) {
      clearTimeout(this._commitTimerID);
    }
    this._commitTimerID = setTimeout(() => {
      this._commitTimerID = null;
      const scheduleRequests = { ...this._scheduleRequests };
      this._scheduleRequests = {};
      let requests = [];
      for (let key in scheduleRequests) {
        requests.push(scheduleRequests[key].request);
      }
      this.__doRequest(requests)
        .then((responses) => {
          for (let i = 0; i < responses.length; i++) {
            const schedule = scheduleRequests[responses[i].id];
            if (responses[i].error) {
              schedule.reject(responses[i].error);
              continue;
            }
            schedule.resolve(responses[i].result);
          }
        })
        .catch((e) => {
          for (let key in requests) {
            if (!requests.hasOwnProperty(key)) {
              continue;
            }
            if (scheduleRequests.hasOwnProperty(requests[key].id)) {
              scheduleRequests[requests[key].id].reject(e);
            }
          }
        });
    }, 0);
  }
  makeJSONRPCRequest(id, method, params) {
    return {
      jsonrpc: "2.0",
      id: id,
      method: method,
      params: params
    };
  }
  /**
   * @param {string} method
   * @param {Object} params
   * @returns {Promise<*>}
   */
  __scheduleRequest(method, params) {
    const p = new Promise((resolve, reject) => {
      const request = this.makeJSONRPCRequest(
        this.__requestIDGenerate(),
        method,
        params
      );
      this._scheduleRequests[request.id] = {
        request,
        resolve,
        reject
      };
    });
    this.__scheduleCommit();
    return p;
  }
  __doRequest(request) {
    return this._transport.doRequest(request);
  }
  __requestIDGenerate() {
    return ++this._requestID;
  }
}
/**
 * @typedef {Object<string, object>} Data
 */

/**
* @typedef {Object} User
* @property {string} title

* @property {string} id
* @property {string} name
* @property {string} password
* @property {GeoJSON} point
* @property {string} last_seen
* @property {Data} data
* @property {Array<number>} photo
* @property {User} user
* @property {Profile} profile
* @property {Recurse} recurse
* @property {string} created_at
* @property {string} updated_at
*/

/**
 * @typedef {Object} Info
 * @property {string} title
 */

/**
 * @typedef {Object} GeoJSON
 * @property {Array<number>} coordinates200
 */

/**
 * @typedef {Object} Profile
 * @property {string} phone
 */

/**
 * @typedef {Object} Recurse
 * @property {string} name
 * @property {Array<Recurse>} recurse
 */

/**
 * @typedef {Array<Member>} Members
 */

/**
 * @typedef {Object} Member
 * @property {string} id
 */

class JSONRPCClientA {
  constructor(transport) {
    this.scheduler = new JSONRPCScheduler(transport);
  }

  /**
   **/
  aTestMethod() {
    return this.scheduler.__scheduleRequest("a.testMethod", {}).catch((e) => {
      throw interfaceATestMethodConvertError(e);
    });
  }
}

class JSONRPCClientB {
  constructor(transport) {
    this.scheduler = new JSONRPCScheduler(transport);
  }

  /**
   *  Create new item of item.
   *
   * @param {Data} newData
   * @param {string} name
   * @param {Array<number>} data
   **/
  bCreate(newData, name, data) {
    return this.scheduler
      .__scheduleRequest("b.create", {
        newData: newData,
        name: name,
        data: data
      })
      .catch((e) => {
        throw interfaceBCreateConvertError(e);
      });
  }
  /**
   * @param {number} id
   * @return {PromiseLike<{a: string, b: string}>}
   **/
  bDelete(id) {
    return this.scheduler
      .__scheduleRequest("b.delete", { id: id })
      .catch((e) => {
        throw interfaceBDeleteConvertError(e);
      });
  }
  /**
   *  Get item.
   *
   * @param {number} id
   * @param {string} name
   * @param {string} fname
   * @param {number} price
   * @param {number} n
   * @param {number} b
   * @param {number} cc
   * @return {PromiseLike<User>}
   **/
  bGet(id, name, fname, price, n, b, cc) {
    return this.scheduler
      .__scheduleRequest("b.get", {
        id: id,
        name: name,
        fname: fname,
        price: price,
        n: n,
        b: b,
        cc: cc
      })
      .catch((e) => {
        throw interfaceBGetConvertError(e);
      });
  }
  /**
   *  GetAll more comment and more and more comment and more and more comment and more.
   *  New line comment.
   *
   * @param {Members} members
   * @return {PromiseLike<Array<User>>}
   **/
  bGetAll(members) {
    return this.scheduler
      .__scheduleRequest("b.getAll", { members: members })
      .catch((e) => {
        throw interfaceBGetAllConvertError(e);
      });
  }
  /**
   * @param {Object<string, object>} data
   * @param {object} ss
   * @return {PromiseLike<Object<string, Object<string, Array<string>>>>}
   **/
  bTestMethod(data, ss) {
    return this.scheduler
      .__scheduleRequest("b.testMethod", { data: data, ss: ss })
      .catch((e) => {
        throw interfaceBTestMethodConvertError(e);
      });
  }
  /**
   * @param {string} ns
   * @param {string} utype
   * @param {string} user
   * @param {string} restype
   * @param {string} resource
   * @param {string} permission
   **/
  bTestMethod2(ns, utype, user, restype, resource, permission) {
    return this.scheduler
      .__scheduleRequest("b.testMethod2", {
        ns: ns,
        utype: utype,
        user: user,
        restype: restype,
        resource: resource,
        permission: permission
      })
      .catch((e) => {
        throw interfaceBTestMethod2ConvertError(e);
      });
  }
}

class JSONRPCClient {
  constructor(transport) {
    this.A = new JSONRPCClientA(transport);
    this.B = new JSONRPCClientB(transport);
  }
}
export default JSONRPCClient;

export class ErrUnauthorizedError extends JSONRPCError {
  constructor(message, data) {
    super(message, "ErrUnauthorizedError", -32001, data);
  }
}
function interfaceATestMethodConvertError(e) {
  switch (e.code) {
    default:
      return new JSONRPCError(e.message, "UnknownError", e.code, e.data);
  }
}
function interfaceBCreateConvertError(e) {
  switch (e.code) {
    default:
      return new JSONRPCError(e.message, "UnknownError", e.code, e.data);
    case -32001:
      return new ErrUnauthorizedError(e.message, e.data);
  }
}
function interfaceBDeleteConvertError(e) {
  switch (e.code) {
    default:
      return new JSONRPCError(e.message, "UnknownError", e.code, e.data);
  }
}
function interfaceBGetConvertError(e) {
  switch (e.code) {
    default:
      return new JSONRPCError(e.message, "UnknownError", e.code, e.data);
  }
}
function interfaceBGetAllConvertError(e) {
  switch (e.code) {
    default:
      return new JSONRPCError(e.message, "UnknownError", e.code, e.data);
  }
}
function interfaceBTestMethodConvertError(e) {
  switch (e.code) {
    default:
      return new JSONRPCError(e.message, "UnknownError", e.code, e.data);
  }
}
function interfaceBTestMethod2ConvertError(e) {
  switch (e.code) {
    default:
      return new JSONRPCError(e.message, "UnknownError", e.code, e.data);
  }
}
