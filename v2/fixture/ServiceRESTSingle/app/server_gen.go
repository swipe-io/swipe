//+build !swipe

// Code generated by Swipe v2.0.0-rc4. DO NOT EDIT.

package app

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	http2 "net/http"
	"strconv"
	"time"

	"github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pquerna/ffjson/ffjson"
)

type errorWrapper struct {
	Error string      `json:"error"`
	Data  interface{} `json:"data,omitempty"`
}

func defaultErrorEncoder(ctx context.Context, err error, w http2.ResponseWriter) {
	var errData interface{}
	if e, ok := err.(interface{ ErrorData() interface{} }); ok {
		errData = e.ErrorData()
	}
	data, merr := ffjson.Marshal(errorWrapper{Error: err.Error(), Data: errData})
	if merr != nil {
		_, _ = w.Write([]byte("unexpected error"))
		return
	}
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	if headerer, ok := err.(http.Headerer); ok {
		for k, values := range headerer.Headers() {
			for _, v := range values {
				w.Header().Add(k, v)
			}
		}
	}
	code := http2.StatusInternalServerError
	if sc, ok := err.(http.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	_, _ = w.Write(data)
}

func encodeResponseHTTP(ctx context.Context, w http2.ResponseWriter, response interface{}) (err error) {
	contentType := "application/json; charset=utf-8"
	statusCode := 200
	h := w.Header()
	var data []byte
	if response != nil {
		data, err = ffjson.Marshal(response)
		if err != nil {
			return err
		}
	} else {
		contentType = "text/plain; charset=utf-8"
		statusCode = 201
	}
	h.Set("Content-Type", contentType)
	w.WriteHeader(statusCode)
	w.Write(data)
	return nil
}

// MakeHandlerREST HTTP REST Transport
func MakeHandlerREST(svcAppInterface AppInterface, options ...ServerOption) (http2.Handler, error) {
	opts := &serverOpts{}
	for _, o := range options {
		o(opts)
	}
	opts.genericServerOption = append(opts.genericServerOption, http.ServerErrorEncoder(defaultErrorEncoder))
	epSet := MakeAppInterfaceEndpointSet(svcAppInterface)
	epSet.CreateEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceCreateEndpointMiddleware...))(epSet.CreateEndpoint)
	epSet.DeleteEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceDeleteEndpointMiddleware...))(epSet.DeleteEndpoint)
	epSet.GetEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceGetEndpointMiddleware...))(epSet.GetEndpoint)
	epSet.GetAllEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceGetAllEndpointMiddleware...))(epSet.GetAllEndpoint)
	epSet.StartEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceStartEndpointMiddleware...))(epSet.StartEndpoint)
	epSet.TestMethodEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceTestMethodEndpointMiddleware...))(epSet.TestMethodEndpoint)
	epSet.TestMethod2Endpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceTestMethod2EndpointMiddleware...))(epSet.TestMethod2Endpoint)
	epSet.TestMethodOptionalsEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceTestMethodOptionalsEndpointMiddleware...))(epSet.TestMethodOptionalsEndpoint)
	r := mux.NewRouter()
	r.Methods(http2.MethodPost).Path("/create").Handler(http.NewServer(
		epSet.CreateEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req CreateRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for CreateRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to CreateRequest: %w", err)
			}
			q := r.URL.Query()
			tmpdate := q.Get("date")
			if tmpdate != "" {
				dateResult, err := time.Parse(time.RFC3339, tmpdate)
				if err != nil {
					return nil, err
				}
				req.Date = dateResult
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceCreateServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/delete").Handler(http.NewServer(
		epSet.DeleteEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req DeleteRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for DeleteRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to DeleteRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceDeleteServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/get/{fname}").Handler(http.NewServer(
		epSet.GetEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req GetRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for GetRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to GetRequest: %w", err)
			}
			vars := mux.Vars(r)
			q := r.URL.Query()
			req.Fname = vars["fname"]
			tmpcc := q.Get("cc")
			if tmpcc != "" {
				ccInt, err := strconv.Atoi(tmpcc)
				if err != nil {
					return nil, err
				}
				req.Cc = int(ccInt)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceGetServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/getall").Handler(http.NewServer(
		epSet.GetAllEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req GetAllRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for GetAllRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to GetAllRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceGetAllServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/start").Handler(http.NewServer(
		epSet.StartEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			return nil, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceStartServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/testmethod").Handler(http.NewServer(
		epSet.TestMethodEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req TestMethodRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for TestMethodRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to TestMethodRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceTestMethodServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/testmethod2").Handler(http.NewServer(
		epSet.TestMethod2Endpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req TestMethod2Request
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for TestMethod2Request: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to TestMethod2Request: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceTestMethod2ServerOption...)...,
	))
	r.Methods("GET").Path("/testmethodoptionals").Handler(http.NewServer(
		epSet.TestMethodOptionalsEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req TestMethodOptionalsRequest
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appInterfaceTestMethodOptionalsServerOption...)...,
	))
	return r, nil
}
