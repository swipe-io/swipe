//+build !swipe

// Code generated by Swipe v2.0.0-rc4. DO NOT EDIT.

package app

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	http2 "net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/go-kit/kit/transport/http"
	"github.com/pquerna/ffjson/ffjson"
)

func NewClientREST(tgt string, options ...ClientOption) (AppInterface, error) {
	opts := &clientOpts{}
	c := &clientAppInterface{}
	for _, o := range options {
		o(opts)
	}
	if strings.HasPrefix(tgt, "[") {
		host, port, err := net.SplitHostPort(tgt)
		if err != nil {
			return nil, err
		}
		tgt = host + ":" + port
	}
	u, err := url.Parse(tgt)
	if err != nil {
		return nil, err
	}
	if u.Scheme == "" {
		u.Scheme = "https"
	}
	c.createEndpoint = http.NewClient(
		http2.MethodPost,
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			req, ok := request.(CreateRequest)
			if !ok {
				return fmt.Errorf("couldn't assert request as CreateRequest, got %T", request)
			}
			r.Method = http2.MethodPost
			r.URL.Path += "/create"
			q := r.URL.Query()
			dateStr := req.Date.Format(time.RFC3339)
			q.Add("date", dateStr)
			r.URL.RawQuery = q.Encode()
			data, err := ffjson.Marshal(req)
			if err != nil {
				return fmt.Errorf("couldn't marshal request %T: %s", req, err)
			}
			r.Body = ioutil.NopCloser(bytes.NewBuffer(data))
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceCreateErrorDecode(statusCode)
			}
			return nil, nil
		},
		append(opts.genericClientOption, opts.appInterfaceCreateClientOption...)...,
	).Endpoint()
	c.createEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceCreateEndpointMiddleware...))(c.createEndpoint)
	c.deleteEndpoint = http.NewClient(
		http2.MethodPost,
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			req, ok := request.(DeleteRequest)
			if !ok {
				return fmt.Errorf("couldn't assert request as DeleteRequest, got %T", request)
			}
			r.Method = http2.MethodPost
			r.URL.Path += "/delete"
			data, err := ffjson.Marshal(req)
			if err != nil {
				return fmt.Errorf("couldn't marshal request %T: %s", req, err)
			}
			r.Body = ioutil.NopCloser(bytes.NewBuffer(data))
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceDeleteErrorDecode(statusCode)
			}
			var resp DeleteRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, err
			}
			err = ffjson.Unmarshal(b, &resp)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to DeleteRequest: %s", err)
			}
			return resp, nil
		},
		append(opts.genericClientOption, opts.appInterfaceDeleteClientOption...)...,
	).Endpoint()
	c.deleteEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceDeleteEndpointMiddleware...))(c.deleteEndpoint)
	c.getEndpoint = http.NewClient(
		http2.MethodPost,
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			req, ok := request.(GetRequest)
			if !ok {
				return fmt.Errorf("couldn't assert request as GetRequest, got %T", request)
			}
			r.Method = http2.MethodPost
			fnameStr := req.Fname
			r.URL.Path += fmt.Sprintf("/get/%s", fnameStr)
			q := r.URL.Query()
			ccStr := strconv.FormatInt(int64(req.Cc), 10)
			q.Add("cc", ccStr)
			r.URL.RawQuery = q.Encode()
			data, err := ffjson.Marshal(req)
			if err != nil {
				return fmt.Errorf("couldn't marshal request %T: %s", req, err)
			}
			r.Body = ioutil.NopCloser(bytes.NewBuffer(data))
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceGetErrorDecode(statusCode)
			}
			var resp User
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, err
			}
			err = ffjson.Unmarshal(b, &resp)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to GetRequest: %s", err)
			}
			return resp, nil
		},
		append(opts.genericClientOption, opts.appInterfaceGetClientOption...)...,
	).Endpoint()
	c.getEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceGetEndpointMiddleware...))(c.getEndpoint)
	c.getAllEndpoint = http.NewClient(
		http2.MethodPost,
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			req, ok := request.(GetAllRequest)
			if !ok {
				return fmt.Errorf("couldn't assert request as GetAllRequest, got %T", request)
			}
			r.Method = http2.MethodPost
			r.URL.Path += "/getAll"
			data, err := ffjson.Marshal(req)
			if err != nil {
				return fmt.Errorf("couldn't marshal request %T: %s", req, err)
			}
			r.Body = ioutil.NopCloser(bytes.NewBuffer(data))
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceGetAllErrorDecode(statusCode)
			}
			var resp []*User
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, err
			}
			err = ffjson.Unmarshal(b, &resp)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to GetAllRequest: %s", err)
			}
			return resp, nil
		},
		append(opts.genericClientOption, opts.appInterfaceGetAllClientOption...)...,
	).Endpoint()
	c.getAllEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceGetAllEndpointMiddleware...))(c.getAllEndpoint)
	c.startEndpoint = http.NewClient(
		http2.MethodPost,
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			r.Method = http2.MethodPost
			r.URL.Path += "/start"
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceStartErrorDecode(statusCode)
			}
			return nil, nil
		},
		append(opts.genericClientOption, opts.appInterfaceStartClientOption...)...,
	).Endpoint()
	c.startEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceStartEndpointMiddleware...))(c.startEndpoint)
	c.testMethodEndpoint = http.NewClient(
		http2.MethodPost,
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			req, ok := request.(TestMethodRequest)
			if !ok {
				return fmt.Errorf("couldn't assert request as TestMethodRequest, got %T", request)
			}
			r.Method = http2.MethodPost
			r.URL.Path += "/testMethod"
			data, err := ffjson.Marshal(req)
			if err != nil {
				return fmt.Errorf("couldn't marshal request %T: %s", req, err)
			}
			r.Body = ioutil.NopCloser(bytes.NewBuffer(data))
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceTestMethodErrorDecode(statusCode)
			}
			var resp map[string]map[int][]string
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, err
			}
			err = ffjson.Unmarshal(b, &resp)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to TestMethodRequest: %s", err)
			}
			return resp, nil
		},
		append(opts.genericClientOption, opts.appInterfaceTestMethodClientOption...)...,
	).Endpoint()
	c.testMethodEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceTestMethodEndpointMiddleware...))(c.testMethodEndpoint)
	c.testMethod2Endpoint = http.NewClient(
		http2.MethodPost,
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			req, ok := request.(TestMethod2Request)
			if !ok {
				return fmt.Errorf("couldn't assert request as TestMethod2Request, got %T", request)
			}
			r.Method = http2.MethodPost
			r.URL.Path += "/testMethod2"
			data, err := ffjson.Marshal(req)
			if err != nil {
				return fmt.Errorf("couldn't marshal request %T: %s", req, err)
			}
			r.Body = ioutil.NopCloser(bytes.NewBuffer(data))
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceTestMethod2ErrorDecode(statusCode)
			}
			return nil, nil
		},
		append(opts.genericClientOption, opts.appInterfaceTestMethod2ClientOption...)...,
	).Endpoint()
	c.testMethod2Endpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceTestMethod2EndpointMiddleware...))(c.testMethod2Endpoint)
	c.testMethodOptionalsEndpoint = http.NewClient(
		"GET",
		u,
		func(_ context.Context, r *http2.Request, request interface{}) error {
			req, ok := request.(TestMethodOptionalsRequest)
			if !ok {
				return fmt.Errorf("couldn't assert request as TestMethodOptionalsRequest, got %T", request)
			}
			r.Method = "GET"
			r.URL.Path += "/testMethodOptionals"
			return nil
		},
		func(_ context.Context, r *http2.Response) (interface{}, error) {
			if statusCode := r.StatusCode; statusCode != http2.StatusOK {
				return nil, appInterfaceTestMethodOptionalsErrorDecode(statusCode)
			}
			return nil, nil
		},
		append(opts.genericClientOption, opts.appInterfaceTestMethodOptionalsClientOption...)...,
	).Endpoint()
	c.testMethodOptionalsEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appInterfaceTestMethodOptionalsEndpointMiddleware...))(c.testMethodOptionalsEndpoint)
	return c, nil
}
