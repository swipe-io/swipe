//+build !swipe

// Code generated by Swipe v2.0.0-rc4. DO NOT EDIT.

package app

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	http2 "net/http"
	"strconv"

	"github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pquerna/ffjson/ffjson"
)

type errorWrapper struct {
	Error string      `json:"error"`
	Data  interface{} `json:"data,omitempty"`
}

func defaultErrorEncoder(ctx context.Context, err error, w http2.ResponseWriter) {
	var errData interface{}
	if e, ok := err.(interface{ ErrorData() interface{} }); ok {
		errData = e.ErrorData()
	}
	data, merr := ffjson.Marshal(errorWrapper{Error: err.Error(), Data: errData})
	if merr != nil {
		_, _ = w.Write([]byte("unexpected error"))
		return
	}
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	if headerer, ok := err.(http.Headerer); ok {
		for k, values := range headerer.Headers() {
			for _, v := range values {
				w.Header().Add(k, v)
			}
		}
	}
	code := http2.StatusInternalServerError
	if sc, ok := err.(http.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	_, _ = w.Write(data)
}

func encodeResponseHTTP(ctx context.Context, w http2.ResponseWriter, response interface{}) (err error) {
	contentType := "application/json; charset=utf-8"
	statusCode := 200
	h := w.Header()
	var data []byte
	if response != nil {
		data, err = ffjson.Marshal(response)
		if err != nil {
			return err
		}
	} else {
		contentType = "text/plain; charset=utf-8"
		statusCode = 201
	}
	h.Set("Content-Type", contentType)
	w.WriteHeader(statusCode)
	w.Write(data)
	return nil
}

// MakeHandlerREST HTTP REST Transport
func MakeHandlerREST(svcA InterfaceA, svcB InterfaceB, options ...ServerOption) (http2.Handler, error) {
	opts := &serverOpts{}
	for _, o := range options {
		o(opts)
	}
	opts.genericServerOption = append(opts.genericServerOption, http.ServerErrorEncoder(defaultErrorEncoder))
	epSetA := MakeAEndpointSet(svcA)
	epSetB := MakeBEndpointSet(svcB)
	epSetA.TestMethodEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.aTestMethodEndpointMiddleware...))(epSetA.TestMethodEndpoint)
	epSetB.CreateEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.bCreateEndpointMiddleware...))(epSetB.CreateEndpoint)
	epSetB.DeleteEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.bDeleteEndpointMiddleware...))(epSetB.DeleteEndpoint)
	epSetB.GetEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.bGetEndpointMiddleware...))(epSetB.GetEndpoint)
	epSetB.GetAllEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.bGetAllEndpointMiddleware...))(epSetB.GetAllEndpoint)
	epSetB.TestMethodEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.bTestMethodEndpointMiddleware...))(epSetB.TestMethodEndpoint)
	epSetB.TestMethod2Endpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.bTestMethod2EndpointMiddleware...))(epSetB.TestMethod2Endpoint)
	r := mux.NewRouter()
	r.Methods("GET").Path("/a/testmethod").Handler(http.NewServer(
		epSetA.TestMethodEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			return nil, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.aTestMethodServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/b/create").Handler(http.NewServer(
		epSetB.CreateEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req BCreateCreateRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for BCreateCreateRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to BCreateCreateRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.bCreateServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/b/delete").Handler(http.NewServer(
		epSetB.DeleteEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req BDeleteDeleteRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for BDeleteDeleteRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to BDeleteDeleteRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.bDeleteServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/b/get-test").Handler(http.NewServer(
		epSetB.GetEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req BGetGetRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for BGetGetRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to BGetGetRequest: %w", err)
			}
			q := r.URL.Query()
			tmpcc := q.Get("cc")
			if tmpcc != "" {
				ccInt, err := strconv.Atoi(tmpcc)
				if err != nil {
					return nil, err
				}
				req.Cc = int(ccInt)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.bGetServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/b/getall").Handler(http.NewServer(
		epSetB.GetAllEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req BGetAllGetAllRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for BGetAllGetAllRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to BGetAllGetAllRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.bGetAllServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/b/testmethod").Handler(http.NewServer(
		epSetB.TestMethodEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req BTestMethodTestMethodRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for BTestMethodTestMethodRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to BTestMethodTestMethodRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.bTestMethodServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/b/testmethod2").Handler(http.NewServer(
		epSetB.TestMethod2Endpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req BTestMethod2TestMethod2Request
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for BTestMethod2TestMethod2Request: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to BTestMethod2TestMethod2Request: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.bTestMethod2ServerOption...)...,
	))
	return r, nil
}
