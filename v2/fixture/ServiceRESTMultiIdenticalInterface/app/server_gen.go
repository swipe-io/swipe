//+build !swipe

// Code generated by Swipe v2.0.0-rc4. DO NOT EDIT.

package app

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	http2 "net/http"

	"github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pquerna/ffjson/ffjson"
	"github.com/swipe-io/swipe/v2/fixture/ServiceRESTMultiIdenticalInterface/app/controller/app1"
	"github.com/swipe-io/swipe/v2/fixture/ServiceRESTMultiIdenticalInterface/app/controller/app2"
)

type errorWrapper struct {
	Error string      `json:"error"`
	Data  interface{} `json:"data,omitempty"`
}

func defaultErrorEncoder(ctx context.Context, err error, w http2.ResponseWriter) {
	var errData interface{}
	if e, ok := err.(interface{ ErrorData() interface{} }); ok {
		errData = e.ErrorData()
	}
	data, merr := ffjson.Marshal(errorWrapper{Error: err.Error(), Data: errData})
	if merr != nil {
		_, _ = w.Write([]byte("unexpected error"))
		return
	}
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	if headerer, ok := err.(http.Headerer); ok {
		for k, values := range headerer.Headers() {
			for _, v := range values {
				w.Header().Add(k, v)
			}
		}
	}
	code := http2.StatusInternalServerError
	if sc, ok := err.(http.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	_, _ = w.Write(data)
}

func encodeResponseHTTP(ctx context.Context, w http2.ResponseWriter, response interface{}) (err error) {
	contentType := "application/json; charset=utf-8"
	statusCode := 200
	h := w.Header()
	var data []byte
	if response != nil {
		data, err = ffjson.Marshal(response)
		if err != nil {
			return err
		}
	} else {
		contentType = "text/plain; charset=utf-8"
		statusCode = 201
	}
	h.Set("Content-Type", contentType)
	w.WriteHeader(statusCode)
	w.Write(data)
	return nil
}

// MakeHandlerREST HTTP REST Transport
func MakeHandlerREST(svcApp app1.App, svcApp app2.App, options ...ServerOption) (http2.Handler, error) {
	opts := &serverOpts{}
	for _, o := range options {
		o(opts)
	}
	opts.genericServerOption = append(opts.genericServerOption, http.ServerErrorEncoder(defaultErrorEncoder))
	epSetApp1 := MakeAppEndpointSet(svcApp)
	epSetApp2 := MakeAppEndpointSet(svcApp)
	epSetApp1.CreateEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appCreateEndpointMiddleware...))(epSetApp1.CreateEndpoint)
	epSetApp2.CreateEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.appCreateEndpointMiddleware...))(epSetApp2.CreateEndpoint)
	r := mux.NewRouter()
	r.Methods(http2.MethodPost).Path("/app1/create").Handler(http.NewServer(
		epSetApp1.CreateEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req AppCreateRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for AppCreateRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to AppCreateRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appCreateServerOption...)...,
	))
	r.Methods(http2.MethodPost).Path("/app2/create").Handler(http.NewServer(
		epSetApp2.CreateEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req AppCreateRequest
			b, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return nil, fmt.Errorf("couldn't read body for AppCreateRequest: %w", err)
			}
			err = ffjson.Unmarshal(b, &req)
			if err != nil && err != io.EOF {
				return nil, fmt.Errorf("couldn't unmarshal body to AppCreateRequest: %w", err)
			}
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.appCreateServerOption...)...,
	))
	return r, nil
}
